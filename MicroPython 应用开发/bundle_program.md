# 打包程序到固件

当你的项目进行到量产/发布阶段时，你开始面临如何将程序打包到为固件的问题。MicroPython 作为一种特殊的应用形式，在打包过程和普通的 Zephyr 应用有所不同。

## 打包方式

对于 MicroPython 代码来说，你有以下两种方式来打包程序。

### 将程序编译为冻结模块

在应用项目目录下的 `boards/` （若没有就创建一个），增加名为 `manifest.py` 的文件。在其中增加如下内容

```python
freeze("dir", ("file1.py", "file2.py"))
# Other freeze() calls
```

其中第一个参数指代码文件所在的目录，第二参数为 Tuple 对象，指定要编译的若干代码文件。

而后，编辑你的 `CMakeLists.txt` ，增加如下内容

```cmake
set(MICROPY_CROSS_FLAGS -march=armv7emsp)
set(MICROPY_FROZEN_MANIFEST boards/manifest.py)
```

*这里的* `-march` *参数应视设备不同获取对应的值，参考* [编译为 .mpy 文件](../工具/Lisa Plugin MicroPython/commands#compile-mpy) *中的相关描述。*

### 将程序打包到文件系统

在 MicroPython 项目中，我们通常推荐在项目目录下的 `py` 目录中，存放你所有的 Python 代码及其相关资源文件，这有助于你快速的找到你的代码，这也是默认情况下， `lisa mpy fs:build` 命令会去查找的目录。

## 如何选择打包方式

本小节的讨论当然还是基于你可以选择的前提了，如果你并不能选用文件系统，那么直接选择 将程序编译为冻结模块 。

<table>
  <tr>
    <th width="20%"></th>
    <th width="40%">冻结模块</th>
    <th width="40%">文件系统</th>
  </tr>
  <tr>
    <td>运行效率</td>
    <td>作为字节码存在于固件中，运行时无需实时编译。但模块在未使用时也会占用内存资源。</td>
    <td>.py 需要编译成字节码后执行，但不执行时不占用内存资源。打包固件前先编译为 .mpy 文件可以提升效率，但入口函数需要保持 .py</td>
  </tr>
  <tr>
    <td>资源文件<br/>（图片、字体、文本等）</td>
    <td>无直接使用方式。<br/>较为曲折的方式是，将资源文件内容直接转字节数组作为 C 代码的变量或宏存储，编译到固件，仅适用于小文件。</td>
    <td>支持</td>
  </tr>
  <tr>
    <td>热更新</td>
    <td>不支持</td>
    <td>支持。<br/>卸载文件系统后，直接烧录文件系统，再重新挂载即可完成热更新。<br/>基于此特性，也可以实现 AB 分区启动。</td>
  </tr>
</table>

本章节列出了一些常见的业务形态，但更重要的是你要理解这两者之间的特点，才更有助于你选择适合你产品的打包方式。
