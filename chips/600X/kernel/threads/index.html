<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.2">
<title data-react-helmet="true">线程 | 聆思文档中心</title><meta data-react-helmet="true" property="og:url" content="https://github.com/LISTENAI/docs-csk6/chips/600X/kernel/threads"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="线程 | 聆思文档中心"><meta data-react-helmet="true" name="description" content="概述"><meta data-react-helmet="true" property="og:description" content="概述"><link data-react-helmet="true" rel="shortcut icon" href="/docs-csk6/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://github.com/LISTENAI/docs-csk6/chips/600X/kernel/threads"><link data-react-helmet="true" rel="alternate" href="https://github.com/LISTENAI/docs-csk6/chips/600X/kernel/threads" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://github.com/LISTENAI/docs-csk6/chips/600X/kernel/threads" hreflang="x-default"><link rel="stylesheet" href="/docs-csk6/assets/css/styles.e821b6b0.css">
<link rel="preload" href="/docs-csk6/assets/js/runtime~main.2d29022b.js" as="script">
<link rel="preload" href="/docs-csk6/assets/js/main.1f54c7f3.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_vO2r">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" titleclassname="navbar__title" href="/docs-csk6/"><img src="/docs-csk6/img/logo_light.svg" alt="LSOpen Logo" class="themedImage_K3WP themedImage--light_Fy0T navbar__logo"><img src="/docs-csk6/img/logo_dark.svg" alt="LSOpen Logo" class="themedImage_K3WP themedImage--dark_V9oi navbar__logo"></a><a class="navbar__item navbar__link" href="/docs-csk6/chips/4002/Chip_information_4002">芯片</a><a class="navbar__item navbar__link" href="/docs-csk6/tools/LStudio">工具</a><a class="navbar__item navbar__link" href="/docs-csk6/AIsolution/ESR/Quick_start/Scheme_introduction">AI语音应用方案</a><a class="navbar__item navbar__link" href="/docs-csk6/Industrysolution/Scanning_pen/Scheme_introduction">行业Turnkey解决方案</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs-csk6/faq/faq">FAQ</a><a class="navbar__item navbar__link" href="/docs-csk6/school/school">视频课程</a><a class="navbar__item navbar__link" href="/docs-csk6/workorder/workorder">工单</a><div class="react-toggle displayOnlyInLargeViewport_a-w0 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_8pH0"><img src="/docs-csk6/img/light.svg" alt="" class="themedImage_K3WP themedImage--light_Fy0T"><img src="/docs-csk6/img/unlight.svg" alt="" class="themedImage_K3WP themedImage--dark_V9oi"></span></div><div class="react-toggle-track-x"><span class="toggle_8pH0"><img src="/docs-csk6/img/undark.svg" alt="" class="themedImage_K3WP themedImage--light_Fy0T"><img src="/docs-csk6/img/dark.svg" alt="" class="themedImage_K3WP themedImage--dark_V9oi"></span></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="navbar__search searchBarContainer_I7kZ"><input placeholder="搜索" aria-label="Search" class="navbar__search-input"><div class="loadingRing_Zg7X searchBarLoadingRing_J5Ez"><div></div><div></div><div></div><div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" titleclassname="navbar__title" href="/docs-csk6/"><img src="/docs-csk6/img/logo_light.svg" alt="LSOpen Logo" class="themedImage_K3WP themedImage--light_Fy0T navbar__logo"><img src="/docs-csk6/img/logo_dark.svg" alt="LSOpen Logo" class="themedImage_K3WP themedImage--dark_V9oi navbar__logo"></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs-csk6/chips/4002/Chip_information_4002">芯片</a></li><li class="menu__list-item"><a class="menu__link" href="/docs-csk6/tools/LStudio">工具</a></li><li class="menu__list-item"><a class="menu__link" href="/docs-csk6/AIsolution/ESR/Quick_start/Scheme_introduction">AI语音应用方案</a></li><li class="menu__list-item"><a class="menu__link" href="/docs-csk6/Industrysolution/Scanning_pen/Scheme_introduction">行业Turnkey解决方案</a></li><li class="menu__list-item"><a class="menu__link" href="/docs-csk6/faq/faq">FAQ</a></li><li class="menu__list-item"><a class="menu__link" href="/docs-csk6/school/school">视频课程</a></li><li class="menu__list-item"><a class="menu__link" href="/docs-csk6/workorder/workorder">工单</a></li></ul></div></div></div></nav><nav class="navbar subnavbar--fixed-top sub-navbar"><div class="navbar__inner subnavbar__inner"><div class="navbar__items"><a class="subnavbar__item subnavbar__link" dirname="/chips" href="/docs-csk6/chips/4002/Chip_information_4002">CSK4002</a><a aria-current="page" class="subnavbar__item subnavbar__link subnavbar__link--active" dirname="/chips" href="/docs-csk6/chips/600X/overview/chips">CSK600X</a><a class="subnavbar__item subnavbar__link" dirname="/chips" href="/docs-csk6/chips/micropython/index">MicroPython</a></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_Ol8-"><aside class="docSidebarContainer_UfDv"><div class="sidebar_OMtR"><nav class="menu menu--responsive thin-scrollbar menu_2y2e menuWithAnnouncementBar_Lwkw" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_IcOF" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--first menu__link--sublist" type="first" href="#!">简介</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/overview/chips">芯片</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/overview/nanokit">NanoKit 开发套件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/overview/system">系统与软件</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--first menu__link--sublist" type="first" href="#!">开发</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/overview">概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/getting_start">快速开始</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/application_development">应用开发</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/structure">应用代码结构</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/kconfig">应用项目配置</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/device_tree">设备树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/board">自定义板型</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" type="" href="#!" tabindex="-1">烧录与调试</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/gdbdebug/overview">概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/gdbdebug/csk6_load">CSK6 烧录</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/gdbdebug/gdbdebug-daplink">基于 DAPLink 的 GDB 调试</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/gdbdebug/gdbdebug-jlink">基于 J-Link 的 GDB 调试</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" type="" href="#!" tabindex="-1">配套命令行工具</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/tool/lisa_plugin_zephyr/install">安装开发工具</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/tool/lisa_plugin_zephyr/basic">基础命令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/tool/lisa_plugin_zephyr/command_detail">内置命令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/tool/lisa_plugin_zephyr/build_flash_debug">编译 烧录 调试</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/tool/lisa_plugin_zephyr/filesystem">文件系统相关</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/tool/lisa_plugin_zephyr/application_project">应用级提货单</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/tool/lisa_plugin_zephyr/trouble_shooting">疑难解答</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/tool/lisa_plugin_zephyr/release_note">Lisa Zephyr 更新日志</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--first menu__link--sublist" type="first" href="#!">使用示例</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" type="" href="#!" tabindex="-1">外设驱动</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/peripheral/overview">外设驱动的使用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/peripheral/samples/gpio">GPIO</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/peripheral/samples/pwm">PWM</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/peripheral/samples/UART">串口(UART)</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/peripheral/samples/I2C">I2C</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/peripheral/samples/spi">SPI</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/peripheral/samples/ADC">ADC</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/peripheral/samples/RTC">RTC</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/peripheral/samples/watchdog">WatchDog</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" type="" href="#!" tabindex="-1">系统内核</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/kernel/overview">概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/kernel/timer">Timer定时器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/kernel/multithread">多线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/kernel/sync_semaphore">线程间同步之信号量</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/kernel/sync_mutex">线程间同步之互斥量</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/kernel/sync_poll">线程间同步之轮询</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" type="" href="#!" tabindex="-1">系统组件</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/modules/overview">概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/modules/logger">日志</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/modules/usb_class">USB 模块</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/modules/display_kscan">显示&amp;触摸</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/modules/lvgl">LVGL</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" type="" href="#!" tabindex="-1">音频</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/audio/overview">概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/audio/audio_record">录音</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/audio/audio_playback">播音</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/audio/audio_record_play">录音和播音示例</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" type="" href="#!" tabindex="-1">网络</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/network/overview">概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/application/network/wifi_connect">WIFI连接</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--current"><a class="menu__link menu__link--first menu__link--sublist menu__link--active" type="first" href="#!">内核</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs-csk6/chips/600X/kernel/index">内核</a></li><li class="menu__list-item menu__list-item--current"><a class="menu__link menu__link--sublist menu__link--active" type="" href="#!" tabindex="0">内核服务</a><ul class="menu__list"><li class="menu__list-item menu__list-item--current"><a class="menu__link menu__link--sublist menu__link--active" type="" href="#!" tabindex="0">调度、中断与同步</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs-csk6/chips/600X/kernel/threads">线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs-csk6/chips/600X/kernel/system_threads">系统线程</a></li></ul></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--first menu__link--sublist" type="first" href="#!">系统服务</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/kernel/index">内核</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--first menu__link--sublist" type="first" href="#!">构建与配置系统</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/build/index">构建与配置系统</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--first menu__link--sublist" type="first" href="#!">硬件支持</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/hardware/index">硬件支持</a></li></ul></li><li class="menu__list-item"><a href="https://zephyr-docs.listenai.com/reference/index.html" target="_blank" rel="noopener noreferrer" class="menu__link"><span>API 文档<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_qQrU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--first menu__link--sublist" type="first" href="#!">疑难解答</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/FAQ/index">FAQ</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs-csk6/chips/600X/quick_start/doc_issue">反馈</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_dRYS"><div class="container padding-top--md padding-bottom--lg center-container"><div class="row"><div class="col docItemCol_+xOG"><div class="docItemContainer_c+5G"><article><div class="markdown"><header><h1 class="h1Heading_5RMM">线程</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="概述"></a>概述<a class="hash-link" href="#概述" title="Direct link to heading">#</a></h2><p>This section describes kernel services for creating, scheduling, and deleting independently executable threads of instructions.</p><p>A <em>thread</em> is a kernel object that is used for application processing that is too lengthy or too complex to be performed by an ISR.</p><p>Any number of threads can be defined by an application (limited only by available RAM). Each thread is referenced by a <em>thread id</em> that is assigned when the thread is spawned。</p><p>本节主要描述线程的创建、调度和删除。</p><p>线程作为一个内核对象，用于应用程序处理过于冗余复杂的应用程序。</p><p>应用程序可以定义任意数量的线程(受RAM的限制)。每个线程都可通过线程 id进行引用，这个线程 id 是在线程产生时分配的。</p><p>A thread has the following key properties:</p><ul><li>A <strong>stack area</strong>, which is a region of memory used for the thread’s stack. The <strong>size</strong> of the stack area can be tailored to conform to the actual needs of the thread’s processing. Special macros exist to create and work with stack memory regions.</li><li>A <strong>thread control block</strong> for private kernel bookkeeping of the thread’s metadata. This is an instance of type <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#c.k_thread%20%22k_thread%22" target="_blank" rel="noopener noreferrer">k_thread</a>.</li><li>An <strong>entry point function</strong>, which is invoked when the thread is started. Up to 3 <strong>argument values</strong> can be passed to this function.</li><li>A <strong>scheduling priority</strong>, which instructs the kernel’s scheduler how to allocate CPU time to the thread. (See <a href="https://docs.zephyrproject.org/latest/kernel/services/scheduling/index.html#scheduling-v2" target="_blank" rel="noopener noreferrer">Scheduling</a>.)</li><li>A set of <strong>thread options</strong>, which allow the thread to receive special treatment by the kernel under specific circumstances. (See <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#thread-options-v2" target="_blank" rel="noopener noreferrer">Thread Options</a>.)</li><li>A <strong>start delay</strong>, which specifies how long the kernel should wait before starting the thread.</li></ul><p>线程具有以下关键属性:</p><ul><li>栈区域：用于线程的栈区域。Zephyr提供一些宏来定义线程栈区域。</li><li>线程控制块：用于管理线程的一个数据结构。详见<code>k_thread</code>。</li><li>入口函数：线程启动时调用的函数。该函数最多能接收 3 个参数。</li><li>调度优先级：指示内核的调度器如何给该线程分配 CPU 时间。</li><li>启动时延：线程在启动前需要等待的时间。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="生命周期"></a>生命周期<a class="hash-link" href="#生命周期" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="线程创建"></a>线程创建<a class="hash-link" href="#线程创建" title="Direct link to heading">#</a></h3><p>A thread must be created before it can be used. The kernel initializes the thread control block as well as one end of the stack portion. The remainder of the thread’s stack is typically left uninitialized.</p><p>线程必须先创建、再使用。创建线程时，内核将初始化线程栈区域的控制块区域以及栈底。栈区域的其它部分通常都是未初始化的。</p><p>Specifying a start delay of <a href="https://docs.zephyrproject.org/latest/kernel/services/timing/clocks.html#c.K_NO_WAIT%20%22K_NO_WAIT%22" target="_blank" rel="noopener noreferrer">K_NO_WAIT</a> instructs the kernel to start thread execution immediately. Alternatively, the kernel can be instructed to delay execution of the thread by specifying a timeout value – for example, to allow device hardware used by the thread to become available.</p><p>如果线程的启动时延是<code>K_NO_WAIT</code>，内核将立即启动线程。也可以指定一个超时时间，让内核延迟启动该线程。例如，让线程需要使用的设备就绪后再启动线程。</p><p>The kernel allows a delayed start to be canceled before the thread begins executing. A cancellation request has no effect if the thread has already started. A thread whose delayed start was successfully canceled must be re-spawned before it can be used.</p><p>如果延迟启动的线程还未启动，内核可以取消该线程。如果线程已经启动了，则内核在尝试取消它时不会有任何效果。如果延迟启动的线程被成功地取消了，它必须被再次创建后才能再次使用。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="代码实现"></a>代码实现<a class="hash-link" href="#代码实现" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="线程结束"></a>线程结束<a class="hash-link" href="#线程结束" title="Direct link to heading">#</a></h3><p>Once a thread is started it typically executes forever. However, a thread may synchronously end its execution by returning from its entry point function. This is known as <strong>termination</strong>.</p><p>线程一旦启动，它通常会一直运行下去。不过，线程也可以从它的入口点函数中返回，从而结束执行。这种结束方式叫做 <strong>正常结束（terminaltion）</strong>。</p><p>A thread that terminates is responsible for releasing any shared resources it may own (such as mutexes and dynamically allocated memory) prior to returning, since the kernel does <em>not</em> reclaim them automatically.</p><p>正常结束的线程需要在返回前释放它所拥有的共享资源（例如互斥量、动态分配的内存）。内核不会自动回收这些资源。</p><p>In some cases a thread may want to sleep until another thread terminates. This can be accomplished with the <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#c.k_thread_join%20%22k_thread_join%22" target="_blank" rel="noopener noreferrer">k_thread_join()</a> API. This will block the calling thread until either the timeout expires, the target thread self-exits, or the target thread aborts (either due to a <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#c.k_thread_abort%20%22k_thread_abort%22" target="_blank" rel="noopener noreferrer">k_thread_abort()</a> call or triggering a fatal error).</p><p>在某些情况下，一个线程想睡眠直到另外一个线程结束。这个功能可以通过<code>k_thread_join()</code> 来实现。这将阻塞调用线程，直到超时到期、目标线程退出或目标线程中止(由于<code>k_thread_abort()</code>调用或触发致命错误)。</p><p>Once a thread has terminated, the kernel guarantees that no use will be made of the thread struct. The memory of such a struct can then be re-used for any purpose, including spawning a new thread. </p><p>Note that the thread must be fully terminated, which presents race conditions where a thread’s own logic signals completion which is seen by another thread before the kernel processing is complete. Under normal circumstances, application code should use <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#c.k_thread_join%20%22k_thread_join%22" target="_blank" rel="noopener noreferrer">k_thread_join()</a> or <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#c.k_thread_abort%20%22k_thread_abort%22" target="_blank" rel="noopener noreferrer">k_thread_abort()</a> to synchronize on thread termination state and not rely on signaling from within application logic.</p><p>一旦线程结束，内核保证不会使用该线程结构。这块结构的内存可被重用于任何目的，包括创建新线程。</p><p>不建议使用内部逻辑信号来判断线程是否结束，这样不能保证线程完全终止，内核可能仍在使用该线程结构的内存，出现竞争条件。在正常情况下，应用程序代码应该使用<code>k_thread_join()</code>或<code>k_thread_abort()</code>同步的结束，而不依赖于应用程序逻辑内部的信号。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="线程终止-thread-aborting"></a>线程终止 Thread Aborting<a class="hash-link" href="#线程终止-thread-aborting" title="Direct link to heading">#</a></h3><p>A thread may asynchronously end its execution by <strong>aborting</strong>. The kernel automatically aborts a thread if the thread triggers a fatal error condition, such as dereferencing a null pointer.</p><p>线程可以通过 <strong>异常终止 （aborting）</strong> 异步结束其执行。如果线程触发了一个致命错误（例如引用了空指针），内核将自动终止该线程。</p><p>A thread can also be aborted by another thread (or by itself) by calling <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#c.k_thread_abort%20%22k_thread_abort%22" target="_blank" rel="noopener noreferrer">k_thread_abort()</a>. However, it is typically preferable to signal a thread to terminate itself gracefully, rather than aborting it.</p><p>其它线程（或线程自己）可以调用 <code>k_thread_abort()</code> 终止一个线程。不过，更优雅的做法是向线程发送一个信号，让该线程自己结束执行。</p><p>As with thread termination, the kernel does not reclaim shared resources owned by an aborted thread.</p><p>线程终止时，内核不会自动回收该线程拥有的共享资源。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="线程挂起-thread-suspension"></a>线程挂起 Thread Suspension<a class="hash-link" href="#线程挂起-thread-suspension" title="Direct link to heading">#</a></h3><p>A thread can be prevented from executing for an indefinite period of time if it becomes <strong>suspended</strong>. The function <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#c.k_thread_suspend%20%22k_thread_suspend%22" target="_blank" rel="noopener noreferrer">k_thread_suspend()</a> can be used to suspend any thread, including the calling thread. Suspending a thread that is already suspended has no additional effect.</p><p>如果一个线程被挂起（suspended），它将在若干周期内内暂停执行。函数<code>k_thread_suspend()</code>可以用于挂起包括调用线程在内的所有线程。对已经挂起的线程再次挂起时不会产生任何效果。</p><p>Once suspended, a thread cannot be scheduled until another thread calls <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#c.k_thread_resume%20%22k_thread_resume%22" target="_blank" rel="noopener noreferrer">k_thread_resume()</a> to remove the suspension.</p><p>线程一旦被挂起，它将一直不能被调度，除非另一个线程调用 <code>k_thread_resume()</code> 取消挂起。</p><p>NOTE：A thread can prevent itself from executing for a specified period of time using <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#c.k_sleep%20%22k_sleep%22" target="_blank" rel="noopener noreferrer">k_sleep()</a>. However, this is different from suspending a thread since a sleeping thread becomes executable automatically when the time limit is reached.</p><p>注：线程可以使用<code>k_sleep()</code>睡眠一段指定的时间。不过，这与挂起不同，睡眠线程在睡眠时间完成后会自动运行。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="线程状态-thread-states"></a>线程状态 Thread States<a class="hash-link" href="#线程状态-thread-states" title="Direct link to heading">#</a></h3><p>A thread that has no factors that prevent its execution is deemed to be <strong>ready</strong>, and is eligible to be selected as the current thread.</p><p>如果一个线程没有其他条件阻止它运行，则可认为该线程处于<strong>就绪状态</strong>，具备被调度为当前线程的条件。</p><p>A thread that has one or more factors that prevent its execution is deemed to be <strong>unready</strong>, and cannot be selected as the current thread.</p><p>不译</p><p>The following factors make a thread unready:</p><ul><li>The thread has not been started.</li><li>The thread is waiting for a kernel object to complete an operation. (For example, the thread is taking a semaphore that is unavailable.)</li><li>The thread is waiting for a timeout to occur.</li><li>The thread has been suspended.</li><li>The thread has terminated or aborted.</li></ul><p>有下面因素可以让线程处于未就绪态：</p><ul><li>该线程未开始</li><li>该线程在阻塞等待其他条件（比如该线程正在等待获取信号量）</li><li>该线程等待超时执行</li><li>该线程已经被挂起</li><li>该线程已经结束或终止</li></ul><p><img src="https://docs.zephyrproject.org/latest/_images/thread_states.svg" alt="Thread States"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="线程栈对象-thread-stack-objects"></a>线程栈对象 Thread Stack objects<a class="hash-link" href="#线程栈对象-thread-stack-objects" title="Direct link to heading">#</a></h2><p>Every thread requires its own stack buffer for the CPU to push context.</p><p>每个线程都需有一块独占的内存块保存线程的上下文。</p><p>Depending on configuration, there are several constraints that must be met:</p><ul><li>There may need to be additional memory reserved for memory management structures</li><li>If guard-based stack overflow detection is enabled, a small write- protected memory management region must immediately precede the stack buffer to catch overflows.</li><li>If userspace is enabled, a separate fixed-size privilege elevation stack must be reserved to serve as a private kernel stack for handling system calls.</li><li>If userspace is enabled, the thread’s stack buffer must be appropriately sized and aligned such that a memory protection region may be programmed to exactly fit.</li></ul><p>根据配置的不同，有几个必须满足的约束条件：</p><ul><li>可能需要为用于内存管理的结构体保留额外的内存</li><li>如果启用了基于保护的栈溢出检测，则必须在栈缓冲区的前面设置一个小的写保护内存管理区域来捕获溢出。</li></ul><p>The alignment constraints can be quite restrictive, for example some MPUs require their regions to be of some power of two in size, and aligned to its own size.</p><p>暂不译</p><p>Because of this, portable code can’t simply pass an arbitrary character buffer to <a href="https://docs.zephyrproject.org/latest/kernel/services/threads/index.html#c.k_thread_create%20%22k_thread_create%22" target="_blank" rel="noopener noreferrer">k_thread_create()</a>. Special macros exist to instantiate stacks, prefixed with K_KERNEL_STACK and K_THREAD_STACK.</p><p>因此，可移植代码不能简单地将缓冲区传递给<code>k_thread_create()</code>。需要使用实例化堆栈的特殊宏，以<code>K_KERNEL_STACK</code>和<code>K_THREAD_STACK</code>为前缀。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="内核栈-kernel-only-stacks"></a>内核栈 Kernel-only Stacks<a class="hash-link" href="#内核栈-kernel-only-stacks" title="Direct link to heading">#</a></h3><p>If it is known that a thread will never run in user mode, or the stack is being used for special contexts like handling interrupts, it is best to define stacks using the K_KERNEL_STACK macros.</p><p>如果一个线程永远不会在用户模式下运行，或者堆栈被用于处理中断等特殊情况，最好是使用<code>K_KERNEL_STACK</code>宏来定义堆栈。</p><p>These stacks save memory because an MPU region will never need to be programmed to cover the stack buffer itself, and the kernel will not need to reserve additional room for the privilege elevation stack, or memory management data structures which only pertain to user mode threads.</p><p>这些堆栈节省内存，因为一个MPU区域将永远不需要被编程来覆盖堆栈本身，而且内核将不需要为特权提升堆栈或只属于用户模式线程的内存管理数据结构预留额外的空间。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="线程栈-thread-stacks"></a>线程栈 Thread stacks<a class="hash-link" href="#线程栈-thread-stacks" title="Direct link to heading">#</a></h3><p>If it is known that a stack will need to host user threads, or if this cannot be determined, define the stack with K_THREAD_STACK macros. This may use more memory but the stack object is suitable for hosting user threads.</p><p>如果一个堆栈需要承载用户线程，或者无法确定，就用<code>K_THREAD_STACK</code>宏定义堆栈。这可能会使用更多的内存，但堆栈对象适合承载用户线程。</p><p>在没有配置<code>CONFIG_USERSPACE</code>的情况下，线程栈等同于内核栈。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="线程优先级-thread-priorities"></a>线程优先级 Thread Priorities<a class="hash-link" href="#线程优先级-thread-priorities" title="Direct link to heading">#</a></h3><p>A thread’s priority is an integer value, and can be either negative or non-negative. Numerically lower priorities takes precedence over numerically higher values. For example, the scheduler gives thread A of priority 4 <em>higher</em> priority over thread B of priority 7; likewise thread C of priority -2 has higher priority than both thread A and thread B.</p><p>线程的优先级是一个整数值，可以是非负数或负数的。数值较低的优先级优先于数值较高的值。例如，优先级为4的线程A比优先级为7的线程B更高的优先级;同样，优先级为-2的线程C的优先级高于线程A和线程B。</p><p>The scheduler distinguishes between two classes of threads, based on each thread’s priority.</p><ul><li>A <em>cooperative thread</em> has a negative priority value. Once it becomes the current thread, a cooperative thread remains the current thread until it performs an action that makes it unready.</li><li>A <em>preemptible thread</em> has a non-negative priority value. Once it becomes the current thread, a preemptible thread may be supplanted at any time if a cooperative thread, or a preemptible thread of higher or equal priority, becomes ready.</li></ul><p>调度程序根据每个线程的优先级区分两类线程：</p><ul><li>协作式线程使用负数优先级数值。一旦变为当前线程，协作线程将会持续保留，直到它执行动作进入未就绪状态。</li><li>抢占线程的优先级是<strong>非负数。</strong>一旦变为当前线程，抢占线程可以被高优先级的抢占线程和协作线程抢占。</li></ul><p>A thread’s initial priority value can be altered up or down after the thread has been started. Thus it is possible for a preemptible thread to become a cooperative thread, and vice versa, by changing its priority.</p><p>线程的初始优先级值可以在线程启动后更改。因此，通过改变优先级，一个可抢占式线程有可能成为一个协作式线程，反之亦然。</p><p>The kernel supports a virtually unlimited number of thread priority levels. The configuration options <a href="https://docs.zephyrproject.org/latest/kconfig.html#CONFIG_NUM_COOP_PRIORITIES%20%22CONFIG_NUM_COOP_PRIORITIES%22" target="_blank" rel="noopener noreferrer">CONFIG_NUM_COOP_PRIORITIES</a> and <a href="https://docs.zephyrproject.org/latest/kconfig.html#CONFIG_NUM_PREEMPT_PRIORITIES%20%22CONFIG_NUM_PREEMPT_PRIORITIES%22" target="_blank" rel="noopener noreferrer">CONFIG_NUM_PREEMPT_PRIORITIES</a> specify the number of priority levels for each class of thread, resulting in the following usable priority ranges:</p><p>Zephyr内核可以支持无上限的优先级数。可以通过<code>CONFIG_NUM_COOP_PRIORITIES</code> 和<code>CONFIG_NUM_PREEMPT_PRIORITIES</code> 进行配置。产生以下可用的优先级范围:</p><ul><li>协作式线程: (<code>-CONFIG_NUM_COOP_PRIORITIES</code> to -1</li><li>抢占式线程: 0 to (<code>CONFIG_NUM_PREEMPT_PRIORITIES</code> - 1)</li></ul><p><img src="https://docs.zephyrproject.org/latest/_images/priorities.svg" alt="Thread Priorities"></p><p>For example, configuring 5 cooperative priorities and 10 preemptive priorities results in the ranges -5 to -1 and 0 to 9, respectively.</p><p>例如配置5个协作优先级和10个抢占优先级，其取值范围分别为-5 ~ -1和0 ~ 9。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_k6ZT" id="线程自定义数据-thread-custom-data"></a>线程自定义数据 Thread Custom Data<a class="hash-link" href="#线程自定义数据-thread-custom-data" title="Direct link to heading">#</a></h2><p>Every thread has a 32-bit custom data area, accessible only by the thread itself, and may be used by the application for any purpose it chooses. The default custom data value for a thread is zero.</p><p>每个线程都有一个32位的自定义数据区，只有线程自己可以访问，应用程序可以选择用于任何目的。线程的默认自定义数据值为零。</p><p>NOTE：Custom data support is not available to ISRs because they operate within a single shared kernel interrupt handling context.</p><p>注意：ISRs不支持自定义数据，因为它们在一个共享内核中断处理上下文中操作。</p><p>By default, thread custom data support is disabled. The configuration option CONFIG_THREAD_CUSTOM_DATA can be used to enable support.</p><p>默认情况下，线程自定义数据支持是禁用的。可以使用配置选项<code>CONFIG_THREAD_CUSTOM_DATA</code>来启用支持。</p><p>The k_thread_custom_data_set() and k_thread_custom_data_get() functions are used to write and read a thread’s custom data, respectively. A thread can only access its own custom data, and not that of another thread.</p><p><code>k_thread_custom_data_set()</code>和<code>k_thread_custom_data_get()</code>函数分别用于写入和读取线程的自定义数据。一个线程只能访问它自己的自定义数据，而不能访问其他线程的数据。</p><p>The following code uses the custom data feature to record the number of times each thread calls a specific routine.</p><p>下面的代码使用自定义数据特性来记录每个线程调用特定例程的次数。</p><div class="codeBlockContainer_9aag"><div class="codeBlockContent_0VPv c"><pre tabindex="0" class="prism-code language-c codeBlock_pSDi thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><div class="codeBlockLines_sq2l"><span class="token-line" style="color:#9CDCFE"><span class="token keyword" style="color:rgb(86, 156, 214)">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(220, 220, 170)">call_tracking_routine</span><span class="token punctuation" style="color:rgb(212, 212, 212)">(</span><span class="token keyword" style="color:rgb(86, 156, 214)">void</span><span class="token punctuation" style="color:rgb(212, 212, 212)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain"></span><span class="token punctuation" style="color:rgb(212, 212, 212)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    </span><span class="token class-name" style="color:rgb(78, 201, 176)">uint32_t</span><span class="token plain"> call_count</span><span class="token punctuation" style="color:rgb(212, 212, 212)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    </span><span class="token keyword" style="color:rgb(86, 156, 214)">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(212, 212, 212)">(</span><span class="token function" style="color:rgb(220, 220, 170)">k_is_in_isr</span><span class="token punctuation" style="color:rgb(212, 212, 212)">(</span><span class="token punctuation" style="color:rgb(212, 212, 212)">)</span><span class="token punctuation" style="color:rgb(212, 212, 212)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(212, 212, 212)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        </span><span class="token comment" style="color:rgb(106, 153, 85)">/* ignore any call made by an ISR */</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(212, 212, 212)">}</span><span class="token plain"> </span><span class="token keyword" style="color:rgb(86, 156, 214)">else</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(212, 212, 212)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        call_count </span><span class="token operator" style="color:rgb(212, 212, 212)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(212, 212, 212)">(</span><span class="token class-name" style="color:rgb(78, 201, 176)">uint32_t</span><span class="token punctuation" style="color:rgb(212, 212, 212)">)</span><span class="token function" style="color:rgb(220, 220, 170)">k_thread_custom_data_get</span><span class="token punctuation" style="color:rgb(212, 212, 212)">(</span><span class="token punctuation" style="color:rgb(212, 212, 212)">)</span><span class="token punctuation" style="color:rgb(212, 212, 212)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        call_count</span><span class="token operator" style="color:rgb(212, 212, 212)">++</span><span class="token punctuation" style="color:rgb(212, 212, 212)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">        </span><span class="token function" style="color:rgb(220, 220, 170)">k_thread_custom_data_set</span><span class="token punctuation" style="color:rgb(212, 212, 212)">(</span><span class="token punctuation" style="color:rgb(212, 212, 212)">(</span><span class="token keyword" style="color:rgb(86, 156, 214)">void</span><span class="token plain"> </span><span class="token operator" style="color:rgb(212, 212, 212)">*</span><span class="token punctuation" style="color:rgb(212, 212, 212)">)</span><span class="token plain">call_count</span><span class="token punctuation" style="color:rgb(212, 212, 212)">)</span><span class="token punctuation" style="color:rgb(212, 212, 212)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(212, 212, 212)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    </span><span class="token comment" style="color:rgb(106, 153, 85)">/* do rest of routine&#x27;s processing */</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(212, 212, 212)">.</span><span class="token punctuation" style="color:rgb(212, 212, 212)">.</span><span class="token punctuation" style="color:rgb(212, 212, 212)">.</span><span class="token plain"></span></span><span class="token-line" style="color:#9CDCFE"><span class="token plain"></span><span class="token punctuation" style="color:rgb(212, 212, 212)">}</span></span></div></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Q0gn clean-btn">Copy</button></div></div><p>Use thread custom data to allow a routine to access thread-specific information, by using the custom data as a pointer to a data structure owned by the thread.</p><p>使用线程自定义数据，允许在线程的上下文中访问线程特定的信息，方法是将自定义数据作为指针传递给线程。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs-csk6/chips/600X/kernel/index"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 内核</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs-csk6/chips/600X/kernel/system_threads"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">系统线程 »</div></a></div></nav><div class="gitalk-wrapper"><ul class="gitalk-option"><li class="like"><i class="icon like-icon"></i> <span id="like_num">有帮助  0</span></li><li class="unlike"><i class="icon unlike-icon"></i> <span id="unlike_num">没帮助 0</span></li><li>文档反馈</li></ul></div></div></div><div class="col col--3" style="padding-left:0px"><div class="tableOfContents_k96L thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#概述" class="table-of-contents__link">概述</a></li><li><a href="#生命周期" class="table-of-contents__link">生命周期</a><ul><li><a href="#线程创建" class="table-of-contents__link">线程创建</a></li></ul></li><li><a href="#代码实现" class="table-of-contents__link">代码实现</a><ul><li><a href="#线程结束" class="table-of-contents__link">线程结束</a></li><li><a href="#线程终止-thread-aborting" class="table-of-contents__link">线程终止 Thread Aborting</a></li><li><a href="#线程挂起-thread-suspension" class="table-of-contents__link">线程挂起 Thread Suspension</a></li><li><a href="#线程状态-thread-states" class="table-of-contents__link">线程状态 Thread States</a></li></ul></li><li><a href="#线程栈对象-thread-stack-objects" class="table-of-contents__link">线程栈对象 Thread Stack objects</a><ul><li><a href="#内核栈-kernel-only-stacks" class="table-of-contents__link">内核栈 Kernel-only Stacks</a></li><li><a href="#线程栈-thread-stacks" class="table-of-contents__link">线程栈 Thread stacks</a></li><li><a href="#线程优先级-thread-priorities" class="table-of-contents__link">线程优先级 Thread Priorities</a></li></ul></li><li><a href="#线程自定义数据-thread-custom-data" class="table-of-contents__link">线程自定义数据 Thread Custom Data</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 安徽聆思智能科技有限公司皖ICP备05001217号</div></div></div></footer></div>
<script src="/docs-csk6/assets/js/runtime~main.2d29022b.js"></script>
<script src="/docs-csk6/assets/js/main.1f54c7f3.js"></script>
<script>!function(e,n,s,t,d){e[s]=e[s]||function(){(e[s].a=e[s].a||[]).push(arguments)},(d=n.createElement("script")).async=!0,d.src="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.js",n.body.appendChild(d)}(window,document,"simplemde")</script></body>
</html>